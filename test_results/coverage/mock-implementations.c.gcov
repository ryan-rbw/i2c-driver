        -:    0:Source:mocks/mock-implementations.c
        -:    1:#include "mock-linux-kernel.h"
        -:    2:#include "../test_i2c_driver.h"
        -:    3:
        -:    4:static u32 mock_registers[64];
        -:    5:static struct clk mock_clk = {0};
        -:    6:static struct dma_chan mock_tx_chan = {0};
        -:    7:static struct dma_chan mock_rx_chan = {0};
        -:    8:static struct dma_async_tx_descriptor mock_tx_desc = {0};
        -:    9:static struct dma_async_tx_descriptor mock_rx_desc = {0};
        -:   10:
        -:   11:static bool mock_clk_enabled = false;
        -:   12:static bool mock_completion_done = false;
        -:   13:static bool mock_pm_suspended = false;
        -:   14:static void *mock_dma_tx_buffer = NULL;
        -:   15:static void *mock_dma_rx_buffer = NULL;
        -:   16:
        8:   17:u32 mock_readl(volatile void __iomem *addr)
        -:   18:{
        8:   19:	uintptr_t offset = ((uintptr_t)addr) & 0xFF;
        8:   20:	u32 reg_idx = offset / 4;
        -:   21:	
        8:   22:	if (reg_idx < ARRAY_SIZE(mock_registers)) {
        8:   23:		printf("[MOCK] Reading register 0x%02lx: 0x%08x\n", offset, mock_registers[reg_idx]);
        8:   24:		return mock_registers[reg_idx];
        -:   25:	}
        -:   26:	
    #####:   27:	return 0;
        -:   28:}
        -:   29:
        6:   30:void mock_writel(u32 val, volatile void __iomem *addr)
        -:   31:{
        6:   32:	uintptr_t offset = ((uintptr_t)addr) & 0xFF;
        6:   33:	u32 reg_idx = offset / 4;
        -:   34:	
        6:   35:	if (reg_idx < ARRAY_SIZE(mock_registers)) {
        6:   36:		printf("[MOCK] Writing register 0x%02lx: 0x%08x\n", offset, val);
        6:   37:		mock_registers[reg_idx] = val;
        -:   38:	}
        6:   39:}
        -:   40:
       15:   41:void *devm_kzalloc(struct device *dev, size_t size, int flags)
        -:   42:{
       15:   43:	void *ptr = calloc(1, size);
       15:   44:	printf("[MOCK] Allocated %zu bytes at %p\n", size, ptr);
       15:   45:	return ptr;
        -:   46:}
        -:   47:
    #####:   48:void *devm_ioremap_resource(struct device *dev, struct resource *res)
        -:   49:{
    #####:   50:	void *ptr = malloc(res->end - res->start + 1);
    #####:   51:	printf("[MOCK] Mapped resource 0x%lx-0x%lx to %p\n", res->start, res->end, ptr);
    #####:   52:	return ptr;
        -:   53:}
        -:   54:
    #####:   55:struct clk *devm_clk_get(struct device *dev, const char *id)
        -:   56:{
    #####:   57:	printf("[MOCK] Getting clock '%s'\n", id);
    #####:   58:	return &mock_clk;
        -:   59:}
        -:   60:
    #####:   61:int devm_request_irq(struct device *dev, unsigned int irq, void *handler,
        -:   62:		     unsigned long irqflags, const char *devname, void *dev_id)
        -:   63:{
    #####:   64:	printf("[MOCK] Requesting IRQ %u for device %s\n", irq, devname);
    #####:   65:	return 0;
        -:   66:}
        -:   67:
    #####:   68:int clk_prepare_enable(struct clk *clk)
        -:   69:{
    #####:   70:	printf("[MOCK] Enabling clock\n");
    #####:   71:	mock_clk_enabled = true;
    #####:   72:	return 0;
        -:   73:}
        -:   74:
    #####:   75:void clk_disable_unprepare(struct clk *clk)
        -:   76:{
    #####:   77:	printf("[MOCK] Disabling clock\n");
    #####:   78:	mock_clk_enabled = false;
    #####:   79:}
        -:   80:
    #####:   81:unsigned long clk_get_rate(struct clk *clk)
        -:   82:{
    #####:   83:	return 100000000; // 100MHz
        -:   84:}
        -:   85:
    #####:   86:struct resource *platform_get_resource(struct platform_device *pdev,
        -:   87:					unsigned int type, unsigned int num)
        -:   88:{
        -:   89:	static struct resource mock_res = {
        -:   90:		.start = 0x12345000,
        -:   91:		.end = 0x12345FFF,
        -:   92:		.flags = IORESOURCE_MEM,
        -:   93:	};
        -:   94:	
    #####:   95:	return &mock_res;
        -:   96:}
        -:   97:
    #####:   98:int platform_get_irq(struct platform_device *pdev, unsigned int num)
        -:   99:{
    #####:  100:	return 56; // Mock IRQ number
        -:  101:}
        -:  102:
    #####:  103:void platform_set_drvdata(struct platform_device *pdev, void *data)
        -:  104:{
    #####:  105:	pdev->dev.driver_data = data;
    #####:  106:}
        -:  107:
    #####:  108:int of_property_read_u32(const struct device_node *np, const char *propname, u32 *out_value)
        -:  109:{
    #####:  110:	if (strcmp(propname, "clock-frequency") == 0) {
    #####:  111:		*out_value = 400000;
    #####:  112:		return 0;
    #####:  113:	} else if (strcmp(propname, "timeout-ms") == 0) {
    #####:  114:		*out_value = 1000;
    #####:  115:		return 0;
        -:  116:	}
        -:  117:	
    #####:  118:	return -EINVAL;
        -:  119:}
        -:  120:
    #####:  121:void spin_lock_init(spinlock_t *lock)
        -:  122:{
    #####:  123:	printf("[MOCK] Initializing spinlock\n");
    #####:  124:}
        -:  125:
    #####:  126:void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)
        -:  127:{
    #####:  128:	printf("[MOCK] Acquiring spinlock with IRQ save\n");
    #####:  129:}
        -:  130:
    #####:  131:void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
        -:  132:{
    #####:  133:	printf("[MOCK] Releasing spinlock with IRQ restore\n");
    #####:  134:}
        -:  135:
        2:  136:void init_completion(struct completion *x)
        -:  137:{
        2:  138:	printf("[MOCK] Initializing completion\n");
        2:  139:	mock_completion_done = false;
        2:  140:}
        -:  141:
    #####:  142:void reinit_completion(struct completion *x)
        -:  143:{
    #####:  144:	printf("[MOCK] Reinitializing completion\n");
    #####:  145:	mock_completion_done = false;
    #####:  146:}
        -:  147:
    #####:  148:void complete(struct completion *x)
        -:  149:{
    #####:  150:	printf("[MOCK] Completing completion\n");
    #####:  151:	mock_completion_done = true;
    #####:  152:}
        -:  153:
    #####:  154:unsigned long wait_for_completion_timeout(struct completion *x, unsigned long timeout)
        -:  155:{
    #####:  156:	printf("[MOCK] Waiting for completion (timeout=%lu)\n", timeout);
    #####:  157:	return mock_completion_done ? timeout : 0;
        -:  158:}
        -:  159:
    #####:  160:unsigned long msecs_to_jiffies(const unsigned int m)
        -:  161:{
    #####:  162:	return m;
        -:  163:}
        -:  164:
        -:  165:static void *mock_adapter_data = NULL;
        -:  166:
    #####:  167:void i2c_set_adapdata(struct i2c_adapter *dev, void *data)
        -:  168:{
    #####:  169:	mock_adapter_data = data;
    #####:  170:}
        -:  171:
    #####:  172:void *i2c_get_adapdata(const struct i2c_adapter *dev)
        -:  173:{
    #####:  174:	return mock_adapter_data;
        -:  175:}
        -:  176:
    #####:  177:int i2c_add_numbered_adapter(struct i2c_adapter *adapter)
        -:  178:{
    #####:  179:	printf("[MOCK] Adding I2C adapter '%s'\n", adapter->name);
    #####:  180:	return 0;
        -:  181:}
        -:  182:
    #####:  183:void i2c_del_adapter(struct i2c_adapter *adap)
        -:  184:{
    #####:  185:	printf("[MOCK] Deleting I2C adapter '%s'\n", adap->name);
    #####:  186:}
        -:  187:
    #####:  188:int pm_runtime_get_sync(struct device *dev)
        -:  189:{
    #####:  190:	printf("[MOCK] PM runtime get sync\n");
    #####:  191:	return 0;
        -:  192:}
        -:  193:
    #####:  194:void pm_runtime_put_noidle(struct device *dev)
        -:  195:{
    #####:  196:	printf("[MOCK] PM runtime put noidle\n");
    #####:  197:}
        -:  198:
    #####:  199:void pm_runtime_put(struct device *dev)
        -:  200:{
    #####:  201:	printf("[MOCK] PM runtime put\n");
    #####:  202:}
        -:  203:
    #####:  204:void pm_runtime_mark_last_busy(struct device *dev)
        -:  205:{
    #####:  206:	printf("[MOCK] PM runtime mark last busy\n");
    #####:  207:}
        -:  208:
    #####:  209:void pm_runtime_put_autosuspend(struct device *dev)
        -:  210:{
    #####:  211:	printf("[MOCK] PM runtime put autosuspend\n");
    #####:  212:}
        -:  213:
    #####:  214:void pm_runtime_use_autosuspend(struct device *dev)
        -:  215:{
    #####:  216:	printf("[MOCK] PM runtime use autosuspend\n");
    #####:  217:}
        -:  218:
    #####:  219:void pm_runtime_set_autosuspend_delay(struct device *dev, int delay)
        -:  220:{
    #####:  221:	printf("[MOCK] PM runtime set autosuspend delay: %d\n", delay);
    #####:  222:}
        -:  223:
    #####:  224:void pm_runtime_set_active(struct device *dev)
        -:  225:{
    #####:  226:	printf("[MOCK] PM runtime set active\n");
    #####:  227:}
        -:  228:
    #####:  229:void pm_runtime_enable(struct device *dev)
        -:  230:{
    #####:  231:	printf("[MOCK] PM runtime enable\n");
    #####:  232:}
        -:  233:
    #####:  234:void pm_runtime_disable(struct device *dev)
        -:  235:{
    #####:  236:	printf("[MOCK] PM runtime disable\n");
    #####:  237:}
        -:  238:
    #####:  239:void pm_runtime_get_noresume(struct device *dev)
        -:  240:{
    #####:  241:	printf("[MOCK] PM runtime get noresume\n");
    #####:  242:}
        -:  243:
    #####:  244:bool pm_runtime_status_suspended(struct device *dev)
        -:  245:{
    #####:  246:	return mock_pm_suspended;
        -:  247:}
        -:  248:
    #####:  249:void pm_request_autosuspend(struct device *dev)
        -:  250:{
    #####:  251:	printf("[MOCK] PM request autosuspend\n");
    #####:  252:}
        -:  253:
    #####:  254:size_t strlcpy(char *dest, const char *src, size_t size)
        -:  255:{
    #####:  256:	size_t len = strlen(src);
    #####:  257:	if (size > 0) {
    #####:  258:		size_t copy_len = (len < size - 1) ? len : size - 1;
    #####:  259:		memcpy(dest, src, copy_len);
    #####:  260:		dest[copy_len] = '\0';
        -:  261:	}
    #####:  262:	return len;
        -:  263:}
        -:  264:
    #####:  265:struct dma_chan *dma_request_chan(struct device *dev, const char *name)
        -:  266:{
    #####:  267:	printf("[MOCK] Requesting DMA channel '%s'\n", name);
        -:  268:	
    #####:  269:	if (strcmp(name, "tx") == 0) {
    #####:  270:		return &mock_tx_chan;
    #####:  271:	} else if (strcmp(name, "rx") == 0) {
    #####:  272:		return &mock_rx_chan;
        -:  273:	}
        -:  274:	
    #####:  275:	return (struct dma_chan *)((long)-ENODEV);
        -:  276:}
        -:  277:
    #####:  278:void dma_release_channel(struct dma_chan *chan)
        -:  279:{
    #####:  280:	printf("[MOCK] Releasing DMA channel\n");
    #####:  281:}
        -:  282:
    #####:  283:int dmaengine_slave_config(struct dma_chan *chan, struct dma_slave_config *config)
        -:  284:{
    #####:  285:	printf("[MOCK] Configuring DMA slave\n");
    #####:  286:	return 0;
        -:  287:}
        -:  288:
    #####:  289:struct dma_async_tx_descriptor *dmaengine_prep_slave_single(struct dma_chan *chan,
        -:  290:	dma_addr_t buf, size_t len, enum dma_transfer_direction dir, unsigned long flags)
        -:  291:{
    #####:  292:	printf("[MOCK] Preparing DMA descriptor (len=%zu, dir=%d)\n", len, dir);
        -:  293:	
    #####:  294:	if (chan == &mock_tx_chan) {
    #####:  295:		return &mock_tx_desc;
    #####:  296:	} else if (chan == &mock_rx_chan) {
    #####:  297:		return &mock_rx_desc;
        -:  298:	}
        -:  299:	
    #####:  300:	return NULL;
        -:  301:}
        -:  302:
    #####:  303:dma_cookie_t dmaengine_submit(struct dma_async_tx_descriptor *desc)
        -:  304:{
    #####:  305:	printf("[MOCK] Submitting DMA descriptor\n");
    #####:  306:	return 1; // Valid cookie
        -:  307:}
        -:  308:
    #####:  309:void dma_async_issue_pending(struct dma_chan *chan)
        -:  310:{
    #####:  311:	printf("[MOCK] Issuing pending DMA\n");
        -:  312:	
        -:  313:	// Simulate DMA completion by calling callback immediately
    #####:  314:	if (chan == &mock_tx_chan && mock_tx_desc.callback) {
    #####:  315:		mock_tx_desc.callback(mock_tx_desc.callback_param);
    #####:  316:	} else if (chan == &mock_rx_chan && mock_rx_desc.callback) {
    #####:  317:		mock_rx_desc.callback(mock_rx_desc.callback_param);
        -:  318:	}
    #####:  319:}
        -:  320:
    #####:  321:bool dma_submit_error(dma_cookie_t cookie)
        -:  322:{
    #####:  323:	return cookie < 0;
        -:  324:}
        -:  325:
    #####:  326:int dmaengine_terminate_all(struct dma_chan *chan)
        -:  327:{
    #####:  328:	printf("[MOCK] Terminating all DMA operations\n");
    #####:  329:	return 0;
        -:  330:}
        -:  331:
    #####:  332:void *dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle, int flag)
        -:  333:{
    #####:  334:	void *ptr = malloc(size);
    #####:  335:	*dma_handle = (dma_addr_t)ptr;
    #####:  336:	printf("[MOCK] Allocated %zu bytes DMA coherent buffer at %p (dma_addr=0x%x)\n", 
        -:  337:	       size, ptr, *dma_handle);
        -:  338:	
    #####:  339:	if (mock_dma_tx_buffer == NULL) {
    #####:  340:		mock_dma_tx_buffer = ptr;
        -:  341:	} else {
    #####:  342:		mock_dma_rx_buffer = ptr;
        -:  343:	}
        -:  344:	
    #####:  345:	return ptr;
        -:  346:}
        -:  347:
    #####:  348:void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t dma_handle)
        -:  349:{
    #####:  350:	printf("[MOCK] Freeing %zu bytes DMA coherent buffer at %p (dma_addr=0x%x)\n", 
        -:  351:	       size, cpu_addr, dma_handle);
    #####:  352:	free(cpu_addr);
    #####:  353:}
        -:  354:
    #####:  355:void mock_set_pm_suspended(bool suspended)
        -:  356:{
    #####:  357:	mock_pm_suspended = suspended;
    #####:  358:}
        -:  359:
    #####:  360:void mock_set_completion_done(bool done)
        -:  361:{
    #####:  362:	mock_completion_done = done;
    #####:  363:}
        -:  364:
        3:  365:void mock_reset_registers(void)
        -:  366:{
        3:  367:	memset(mock_registers, 0, sizeof(mock_registers));
        3:  368:}
        -:  369:
        -:  370:// Mock DMA functions that are tested
        1:  371:int i2c_a78_dma_init(struct i2c_a78_dev *i2c_dev)
        -:  372:{
        1:  373:	printf("[MOCK] i2c_a78_dma_init called\n");
        1:  374:	if (i2c_dev) {
        1:  375:		i2c_dev->dma.use_dma = true;
        1:  376:		i2c_dev->dma.tx_chan = (struct dma_chan *)0x1234; // Mock pointer
        1:  377:		i2c_dev->dma.rx_chan = (struct dma_chan *)0x5678; // Mock pointer
        1:  378:		init_completion(&i2c_dev->dma.tx_complete);
        1:  379:		init_completion(&i2c_dev->dma.rx_complete);
        -:  380:	}
        1:  381:	return 0; // Success for testing
        -:  382:}
        -:  383:
        1:  384:void i2c_a78_dma_release(struct i2c_a78_dev *i2c_dev)
        -:  385:{
        1:  386:	printf("[MOCK] i2c_a78_dma_release called\n");
        1:  387:	if (i2c_dev) {
        1:  388:		i2c_dev->dma.use_dma = false;
        1:  389:		i2c_dev->dma.tx_chan = NULL;
        1:  390:		i2c_dev->dma.rx_chan = NULL;
        -:  391:	}
        1:  392:}
        -:  393:
    #####:  394:int i2c_a78_dma_xfer(struct i2c_a78_dev *i2c_dev, struct i2c_msg *msg)
        -:  395:{
        -:  396:	(void)i2c_dev;
        -:  397:	(void)msg;
    #####:  398:	printf("[MOCK] i2c_a78_dma_xfer called\n");
    #####:  399:	return 0; // Success for testing
        -:  400:}
        -:  401:
        -:  402:// Mock PM functions that are tested
    #####:  403:int i2c_a78_pm_init(struct i2c_a78_dev *i2c_dev)
        -:  404:{
        -:  405:	(void)i2c_dev;
    #####:  406:	printf("[MOCK] i2c_a78_pm_init called\n");
    #####:  407:	return 0;
        -:  408:}
        -:  409:
    #####:  410:int i2c_a78_pm_suspend(struct device *dev)
        -:  411:{
        -:  412:	(void)dev;
    #####:  413:	printf("[MOCK] i2c_a78_pm_suspend called\n");
    #####:  414:	return 0;
        -:  415:}
        -:  416:
    #####:  417:int i2c_a78_pm_resume(struct device *dev)
        -:  418:{
        -:  419:	(void)dev;
    #####:  420:	printf("[MOCK] i2c_a78_pm_resume called\n");
    #####:  421:	return 0;
        -:  422:}
